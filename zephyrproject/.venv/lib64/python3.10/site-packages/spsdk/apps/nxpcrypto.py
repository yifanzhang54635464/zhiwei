#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# Copyright 2022-2025 NXP
#
# SPDX-License-Identifier: BSD-3-Clause

"""CLI application for various cryptographic operations."""

import base64
import hashlib
import logging
import os
import sys
from typing import Any, Optional, Union

import click
from click_option_group import RequiredMutuallyExclusiveOptionGroup, optgroup

from spsdk.apps.nxpcertgen import main as cert_gen_main
from spsdk.apps.utils import spsdk_logger
from spsdk.apps.utils.common_cli_options import (
    CommandsTreeGroup,
    SpsdkClickGroup,
    spsdk_apps_common_options,
    spsdk_family_option,
    spsdk_output_option,
    spsdk_revision_option,
)
from spsdk.apps.utils.utils import INT, SPSDKAppError, catch_spsdk_error
from spsdk.crypto.certificate import Certificate, generate_extensions, generate_name
from spsdk.crypto.crypto_types import SPSDKEncoding
from spsdk.crypto.hash import EnumHashAlgorithm
from spsdk.crypto.keys import (
    PrivateKey,
    PrivateKeyEcc,
    PrivateKeyRsa,
    PrivateKeySM2,
    PublicKey,
    PublicKeyEcc,
    get_ecc_curve,
    get_supported_keys_generators,
)
from spsdk.crypto.signature_provider import get_signature_provider
from spsdk.crypto.utils import extract_public_key
from spsdk.exceptions import SPSDKError, SPSDKIndexError, SPSDKSyntaxError, SPSDKValueError
from spsdk.utils.crypto.rot import Rot
from spsdk.utils.misc import Endianness, get_printable_path, load_binary, write_file

logger = logging.getLogger(__name__)


@click.group(name="nxpcrypto", no_args_is_help=True, cls=CommandsTreeGroup)
@spsdk_apps_common_options
def main(log_level: int) -> None:
    """Collection of utilities for cryptographic operations."""
    spsdk_logger.install(level=log_level)


@main.command(name="digest", no_args_is_help=True)
@click.option(
    "-h",
    "--hash",
    "hash_name",
    required=True,
    type=click.Choice(list(hashlib.algorithms_available), case_sensitive=False),
    help="Name of a hash to use.",
)
@click.option(
    "-i",
    "--input-file",
    type=click.Path(exists=True, dir_okay=False),
    required=True,
    help="Path to a file to digest.",
)
@click.option(
    "-c",
    "--compare",
    metavar="PATH | DIGEST",
    help="Reference digest to compare. It may be directly on the command line or fetched from a file.",
)
def digest(hash_name: str, input_file: str, compare: str) -> None:
    """Computes digest/hash of the given file."""
    data = load_binary(input_file)
    hasher = hashlib.new(hash_name.lower())
    hasher.update(data)
    hexdigest = hasher.hexdigest()
    click.echo(f"{hash_name.upper()}({input_file})= {hexdigest}")
    if compare:
        # assume comparing to a file
        if os.path.isfile(compare):
            with open(compare, encoding="utf-8") as f:
                compare_data = f.readline().strip()
                # assume format generated by openssl
                if "=" in compare_data:
                    ref = compare_data.split("=")[-1].strip()
                # assume hash is on the fist line
                else:
                    ref = compare_data
        else:
            ref = compare
        if ref.lower() == hexdigest.lower():
            click.echo("Digests are the same.")
        else:
            raise SPSDKAppError("Digests differ!")


@main.group(name="rot", no_args_is_help=True, cls=SpsdkClickGroup)
def rot_group() -> None:
    """Group of RoT commands."""


@rot_group.command(name="export", no_args_is_help=True)
@spsdk_family_option(families=Rot.get_supported_families())
@spsdk_revision_option
@click.option(
    "-k",
    "--key",
    type=click.Path(exists=True, dir_okay=False),
    multiple=True,
    help="Path to one or multiple keys or certificates.",
)
@click.option(
    "-p",
    "--password",
    help="Password when using encrypted private keys.",
)
@spsdk_output_option(required=False)
def export(family: str, revision: str, key: list[str], password: str, output: str) -> None:
    """Export RoT table."""
    _rot = Rot(family, revision, keys_or_certs=key, password=password)
    rot_hash = _rot.export()
    click.echo(str(_rot))
    if output:
        write_file(rot_hash, path=output, mode="wb")
        click.echo(f"Result has been stored in: {output}")
    click.echo(f"RoT table: {rot_hash.hex()}")


@rot_group.command(name="calculate-hash", no_args_is_help=True)
@spsdk_family_option(families=Rot.get_supported_families())
@spsdk_revision_option
@click.option(
    "-k",
    "--key",
    type=click.Path(exists=True, dir_okay=False),
    multiple=True,
    help="Path to one or multiple keys or certificates.",
)
@click.option(
    "-p",
    "--password",
    help="Password when using encrypted private keys.",
)
@click.option(
    "-b",
    "--base64",
    "_base64",
    is_flag=True,
    default=False,
    help="Apply base64 encoding on the final RoT hash.",
)
@spsdk_output_option(required=False)
def calculate_hash(
    family: str, revision: str, key: list[str], password: str, output: str, _base64: bool
) -> None:
    """Calculate RoT hash."""
    _rot = Rot(family, revision, keys_or_certs=key, password=password)
    rot_hash = _rot.calculate_hash()
    if _base64:
        rot_hash = base64.b64encode(rot_hash)
        click.echo(f"Base64 encoded RoT hash: '{rot_hash.decode('utf-8')}'")
    else:
        click.echo(f"RoT hash: '{rot_hash.hex()}'")
    if output:
        write_file(rot_hash, path=output, mode="wb")
        click.echo(f"Result has been stored in: {output}")


@main.group(name="cert", no_args_is_help=True, cls=SpsdkClickGroup)
def cert() -> None:
    """Group of command for working with x509 certificates."""


cert.add_command(cert_gen_main.commands["convert"], name="convert")
cert.add_command(cert_gen_main.commands["generate"], name="generate")
cert.add_command(cert_gen_main.commands["get-template"], name="get-template")
cert.add_command(cert_gen_main.commands["verify"], name="verify")


@main.group(name="key", no_args_is_help=True, cls=SpsdkClickGroup)
def key_group() -> None:
    """Group of commands for working with asymmetric keys."""


@key_group.command(name="generate", no_args_is_help=True)
@click.option(
    "-k",
    "--key-type",
    type=click.Choice(list(get_supported_keys_generators()), case_sensitive=False),
    required=True,
    help="Type of key to generate",
)
@click.option(
    "-p",
    "--password",
    "password",
    metavar="PASSWORD",
    help="Password with which the output file will be encrypted. "
    "If not provided, the output will be unencrypted.",
)
@spsdk_output_option(force=True)
@click.option(
    "-e",
    "--encoding",
    type=click.Choice(list(SPSDKEncoding.all()), case_sensitive=False),
    default="PEM",
)
def key_generate(key_type: str, output: str, password: str, encoding: str) -> None:
    """NXP Key Generator Tool."""
    key_param = key_type.lower().strip()
    encoding_param = encoding.upper().strip()
    encoding_enum = SPSDKEncoding.all()[encoding_param]

    if output.endswith(".pub"):
        pub_key_path = output + ".pub"
    else:
        pub_key_path = os.path.splitext(output)[0] + ".pub"

    generators = get_supported_keys_generators()
    func, params = generators[key_param]

    private_key = func(**params)
    public_key = private_key.get_public_key()

    private_key.save(output, password if password else None, encoding=encoding_enum)
    public_key.save(pub_key_path, encoding=encoding_enum)

    click.echo(
        f"The key pair has been created: {get_printable_path(pub_key_path)}, {get_printable_path(output)}"
    )


@key_group.command(name="convert", no_args_is_help=True)
@click.option(
    "-e",
    "--encoding",
    type=click.Choice(["PEM", "DER", "RAW"], case_sensitive=False),
    required=True,
    help="Desired output format.",
)
@click.option(
    "-i",
    "--input-file",
    type=click.Path(exists=True, dir_okay=False),
    required=True,
    help="Path to key file to convert.",
)
@spsdk_output_option()
@click.option(
    "-p",
    "--puk",
    is_flag=True,
    default=False,
    help="Extract public key instead of converting private key.",
)
def convert(encoding: str, input_file: str, output: str, puk: bool) -> None:
    """Convert Asymmetric key into various formats."""
    key_data = load_binary(input_file)
    key = reconstruct_key(key_data=key_data)
    if puk and isinstance(key, (PrivateKeyRsa, PrivateKeyEcc, PrivateKeySM2)):
        key = key.get_public_key()

    if encoding in ["PEM", "DER"]:
        encoding_type = {"PEM": SPSDKEncoding.PEM, "DER": SPSDKEncoding.DER}[encoding]
        out_data = key.export(encoding=encoding_type)
    elif encoding == "RAW":
        if not isinstance(key, (PrivateKeyEcc, PublicKeyEcc)):
            raise SPSDKError("Converting to RAW is supported only for ECC keys")
        key_size = key.key_size // 8
        if isinstance(key, PrivateKeyEcc):
            out_data = key.d.to_bytes(key_size, byteorder=Endianness.BIG.value)
        else:
            x = key.x.to_bytes(key_size, byteorder=Endianness.BIG.value)
            y = key.y.to_bytes(key_size, byteorder=Endianness.BIG.value)
            out_data = x + y
    else:
        raise SPSDKAppError("Desired output encoding format must be specified by -e/--encoding")

    write_file(out_data, output, mode="wb")


@key_group.command(name="verify", no_args_is_help=True)
@click.option(
    "-k1",
    "--key1",
    required=True,
    type=click.Path(exists=True, dir_okay=False),
    help="Path to key to verify.",
)
@click.option(
    "-k2",
    "--key2",
    required=True,
    type=click.Path(exists=True, dir_okay=False),
    help="Path to key for verification.",
)
def key_verify(key1: str, key2: str) -> None:
    """Check whether provided keys form a key pair or represent the same key.

    The key could be private key, public key, or certificate. All combination are allowed.
    In case of certificates, the public key within certificate is considered.
    To verify certificate signature use `nxpcrypto cert verify`.
    """
    if extract_public_key(key1) == extract_public_key(key2):
        click.echo("Keys match.")
    else:
        raise SPSDKAppError("Keys are NOT a valid pair!")


def reconstruct_key(
    key_data: bytes,
) -> Union[PrivateKey, PublicKey]:
    """Reconstruct Crypto key from PEM,DER or RAW data."""
    try:
        return PrivateKey.parse(key_data)
    except SPSDKError:
        pass
    try:
        return PublicKey.parse(key_data)
    except SPSDKError:
        pass
    # attempt to reconstruct key from raw data
    key_length = len(key_data)
    curve = get_ecc_curve(key_length)
    # everything under 49 bytes is a private key
    if key_length <= 48:
        # pylint: disable=invalid-name   # 'd' is regular name for private key number
        d = int.from_bytes(key_data, byteorder=Endianness.BIG.value)
        return PrivateKeyEcc.recreate(d=d, curve=curve)

    # public keys in binary form have exact sizes
    if key_length in [64, 96]:
        coord_length = key_length // 2
        x = int.from_bytes(key_data[:coord_length], byteorder=Endianness.BIG.value)
        y = int.from_bytes(key_data[coord_length:], byteorder=Endianness.BIG.value)
        return PublicKeyEcc.recreate(coor_x=x, coor_y=y, curve=curve)
    raise SPSDKError(f"Can't recognize key with length {key_length}")


@main.group(name="signature", no_args_is_help=True, cls=SpsdkClickGroup)
def signature_group() -> None:
    """Group of commands for working with signature."""


def cut_off_data_regions(data: bytes, regions: list[str]) -> bytes:
    """Get the data chunks from the input data.

    The regions are individual string written in python-like syntax. For example '[:0x10]'
    """
    if not regions:
        return data
    data_chunks = bytes()
    for region in regions:
        try:
            region = region.replace("[", "").replace("]", "")
            # if the region was defined as single index such as [0]
            if ":" not in region:
                idx = int(region, 0)
                data_chunks += data[idx].to_bytes(1, Endianness.BIG.value)
                continue
            start_s, end_s = region.split(":")
            start = int(start_s, 0) if start_s else 0
            end = int(end_s, 0) if end_s else len(data)
            data_chunks += data[start:end]
        except (SyntaxError, NameError, ValueError) as exc:
            raise SPSDKSyntaxError(f"Invalid region expression '{region}'") from exc
        except IndexError as exc:
            raise SPSDKIndexError(
                f"The region expression '{region}' is outside the data length {len(data)}"
            ) from exc
    return data_chunks


@signature_group.command(name="create", no_args_is_help=True)
@optgroup.group("Signee type", cls=RequiredMutuallyExclusiveOptionGroup)
@optgroup.option(
    "-k",
    "--private-key",
    type=click.Path(exists=True, dir_okay=False),
    help=f"""\b
        Path to private key to be used for signing.
        Supported private keys:
        {", ".join(list(get_supported_keys_generators()))}.
        """,
)
@optgroup.option(
    "-sp",
    "--signature-provider",
    type=click.STRING,
    help="Signature provider configuration string.",
)
@click.option(
    "-p",
    "--password",
    type=click.STRING,
    help="Password when using encrypted private keys.",
)
@click.option(
    "-a",
    "--algorithm",
    type=click.Choice(EnumHashAlgorithm.labels(), case_sensitive=False),
    help="Hash algorithm used when signing the message.",
)
@click.option(
    "-i",
    "--input-file",
    required=True,
    type=click.Path(exists=False, dir_okay=False),
    help="Path to file containing binary data to be signed.",
)
@click.option(
    "-e",
    "--encoding",
    type=click.Choice([SPSDKEncoding.NXP.value, SPSDKEncoding.DER.value], case_sensitive=False),
    default=SPSDKEncoding.DER.value,
    help="Encoding of output signature. This option is applicable only when signing with ECC keys.",
)
@click.option(
    "-pp",
    "--pss-padding",
    is_flag=True,
    default=False,
    help="Use PSS padding in case of RSA",
)
@click.option(
    "-r",
    "--regions",
    type=click.STRING,
    multiple=True,
    help="""\b
        Region(s) of data that will be signed. Multiple regions can be specified.

        Format of region option is similar to Python's list indices syntax:

        +--------------+--------------------------+
        | [1]          | Byte with index 1        |
        +--------------+--------------------------+
        | [:20]        | Fist 20 bytes            |
        +--------------+--------------------------+
        | [0x10:0x20]  | Between 0x10 and 0x20    |
        +--------------+--------------------------+
        | [-20:]       | Last 20 bytes            |
        +--------------+--------------------------+
        """,
)
@spsdk_output_option(force=True)
def signature_create(
    private_key: str,
    signature_provider: str,
    password: str,
    algorithm: str,
    input_file: str,
    encoding: str,
    pss_padding: bool,
    regions: list[str],
    output: str,
) -> None:
    """Sign the data with given private key."""
    if not (signature_provider or private_key):
        raise SPSDKValueError("Signature provider or private key must be specified.")
    if signature_provider and private_key:
        raise SPSDKValueError("One of signature provider and private key must be specified.")
    hash_alg = EnumHashAlgorithm.from_label(algorithm) if algorithm else None
    encoding_obj = SPSDKEncoding(encoding.upper()) if encoding else None
    signature_provider_obj = get_signature_provider(
        sp_cfg=signature_provider,
        local_file_key=private_key,
        password=password,
        pss_padding=pss_padding,
        hash_alg=hash_alg,
    )

    data = cut_off_data_regions(load_binary(input_file), regions)
    signature = signature_provider_obj.get_signature(data, encoding_obj)

    write_file(signature, output, mode="wb")
    click.echo(f"The data have been signed. Signature saved to: {output}")


@signature_group.command(name="verify", no_args_is_help=True)
@click.option(
    "-k",
    "--public-key",
    required=True,
    type=click.Path(exists=True, dir_okay=False),
    help=f"""\b
        Path to public key to be used for verification.

        Supported public keys:
        {", ".join(list(get_supported_keys_generators()))}.
        """,
)
@click.option(
    "-a",
    "--algorithm",
    type=click.Choice(EnumHashAlgorithm.labels(), case_sensitive=False),
    help="Hash algorithm used when signing the message. If not set, default algorithm will be used.",
)
@click.option(
    "-i",
    "--input-file",
    required=True,
    type=click.Path(exists=False, dir_okay=False),
    help="Path to file containing original binary data.",
)
@click.option(
    "-s",
    "--signature",
    required=True,
    type=click.Path(exists=True, dir_okay=False),
    help="Path to file containing data signature.",
)
@click.option(
    "-pp",
    "--pss-padding",
    is_flag=True,
    default=False,
    help="Indicate whether the signature uses PSS padding in case of RSA",
)
@click.option(
    "-r",
    "--regions",
    type=click.STRING,
    multiple=True,
    help="""\b
        Region(s) of data that will be signed. Multiple regions can be specified.

        Format of region option is similar to Python's list indices syntax:

        +--------------+--------------------------+
        | [1]          | Byte with index 1        |
        +--------------+--------------------------+
        | [:20]        | Fist 20 bytes            |
        +--------------+--------------------------+
        | [0x10:0x20]  | Between 0x10 and 0x20    |
        +--------------+--------------------------+
        | [-20:]       | Last 20 bytes            |
        +--------------+--------------------------+
        """,
)
def signature_verify(
    public_key: str,
    algorithm: Optional[str],
    input_file: str,
    signature: str,
    pss_padding: bool,
    regions: list[str],
) -> None:
    """Verify the given signature with public key."""
    result = signature_verify_command(
        public_key, algorithm, input_file, signature, pss_padding, regions
    )
    click.echo(f"Signature {'IS' if result else 'IS NOT'} matching the public key.")


def signature_verify_command(
    public_key: str,
    algorithm: Optional[str],
    input_file: str,
    signature: str,
    pss_padding: bool,
    regions: list[str],
) -> bool:
    """Verify the given signature with public key."""
    public = PublicKey.load(public_key)
    extra_params: dict[str, Any] = {"pss_padding": pss_padding}
    if algorithm:
        extra_params["algorithm"] = EnumHashAlgorithm.from_label(algorithm)
    signature_bin = load_binary(signature)
    data = load_binary(input_file)
    data = cut_off_data_regions(data, regions)
    result = public.verify_signature(signature_bin, data, **extra_params)
    return result


@main.group(name="pki-tree", no_args_is_help=True, cls=SpsdkClickGroup)
def pki_group() -> None:
    """Group of commands for generation of PKI tree."""


@pki_group.command(name="ahab", no_args_is_help=True)
@click.option(
    "-k",
    "--key-type",
    type=click.Choice(list(get_supported_keys_generators(basic=True)), case_sensitive=False),
    required=True,
    metavar="KEY-TYPE",
    help=f"""\b
        All possible options:
        {", ".join(list(get_supported_keys_generators(basic=True)))}.
        """,
)
@click.option(
    "-p",
    "--password",
    "password",
    metavar="PASSWORD",
    help="Password with which the keys will be encrypted. "
    "If not provided, the keys will be unencrypted.",
)
@spsdk_output_option(force=True, directory=True)
@click.option(
    "-e",
    "--encoding",
    type=click.Choice(list(SPSDKEncoding.cryptography_encodings()), case_sensitive=False),
    default="PEM",
)
@click.option(
    "-n",
    "--keys-number",
    type=click.IntRange(1, 4),
    default=4,
    help="Number of SRK keys and certificates that will be created (default 4)",
)
@click.option(
    "-d",
    "--duration",
    type=click.IntRange(1, 100),
    default=10,
    help="Duration of certificates validity in years (default 10)",
)
@click.option(
    "-s",
    "--serial",
    type=INT(),
    multiple=True,
    help="""Serial number of SRK certificates. Must be specified for each certificate. E.g.:
    -s 0x12345679 -s 0x1234567a for two certificates. Default is 0x1234567{9...c}.
    """,
)
@click.option(
    "-ca",
    "--srk-is-ca",
    is_flag=True,
    default=False,
    help="True if SRK is certificate authority. In this case SGK keys will be generated",
)
def ahab_tree_generate(
    key_type: str,
    output: str,
    password: str,
    encoding: str,
    keys_number: int,
    duration: int,
    serial: Optional[list[int]],
    srk_is_ca: bool,
) -> None:
    """Generates a basic AHAB PKI tree.

    If the SRKs are chosen to be CA certificates then this command will generate the
    following PKI tree:

    \b
                        CA Certificate
                           | | |
                  -------- + | +---------------
                /            |                 \\
                SRK1        SRK2       ...      SRK N
                |            |                   |
                |            |                   |
                SGK1        SGK2                SGK N

    where: N can be 1 to 4.


    If the SRKs are chosen to be non-CA certificates then this command will
    generate the following PKI tree:

    \b
                     CA Certificate
                          | | |
                 -------- + | +---------------
                /           |                 \\
            SRK1          SRK2       ...      SRK N

    """
    click.echo("Generating PKI Tree for AHAB")
    ahab_tree_generate_command(
        key_type, output, password, encoding, keys_number, duration, serial, srk_is_ca
    )


@pki_group.command(name="hab", no_args_is_help=True)
@click.option(
    "-k",
    "--key-type",
    type=click.Choice(list(get_supported_keys_generators(basic=True)), case_sensitive=False),
    required=True,
    metavar="KEY-TYPE",
    help=f"""\b
        All possible options:
        {", ".join(list(get_supported_keys_generators(basic=True)))}.
        """,
)
@click.option(
    "-p",
    "--password",
    "password",
    metavar="PASSWORD",
    help="Password with which the keys will be encrypted. "
    "If not provided, the keys will be unencrypted.",
)
@spsdk_output_option(force=True, directory=True)
@click.option(
    "-e",
    "--encoding",
    type=click.Choice(list(SPSDKEncoding.cryptography_encodings()), case_sensitive=False),
    default="PEM",
)
@click.option(
    "-n",
    "--keys-number",
    type=click.IntRange(1, 4),
    default=4,
    help="Number of SRK keys and certificates that will be created (default 4)",
)
@click.option(
    "-d",
    "--duration",
    type=click.IntRange(1, 100),
    default=10,
    help="Duration of certificates validity in years (default 10)",
)
@click.option(
    "-s",
    "--serial",
    type=INT(),
    multiple=True,
    help="""Serial number of SRK certificates. Must be specified for each certificate. E.g.:
    -s 0x12345679 -s 0x1234567a for two certificates. Default is 0x1234567{9...c}.
    """,
)
@click.option(
    "-ca",
    "--srk-is-ca",
    is_flag=True,
    default=False,
    help="True if SRK is certificate authority. In this case SGK keys will be generated",
)
def hab_tree_generate(
    key_type: str,
    output: str,
    password: str,
    encoding: str,
    keys_number: int,
    duration: int,
    serial: Optional[list[int]],
    srk_is_ca: bool,
) -> None:
    """Generates a basic HABv4 PKI tree.

    If the SRKs are chosen to be CA certificate then this command will generate the
    following PKI tree:

    \b
                     CA Certificate
                          | | |
                 -------- + | +---------------
                /           |                 \\
             SRK1          SRK2       ...      SRK N
             / \\            / \\                / \\
            /   \\          /   \\              /   \\
        CSF1_1  IMG1_1  CSF2_1  IMG2_1 ... CSF N_1  IMG N_1

    where: N can be 1 to 4.


    If the SRKs are chosen to be non-CA certificate then this command will
    generate the following PKI Certificate:

    \b
                      CA Certificate
                          | | |
                 -------- + | +---------------
                /           |                 \\
            SRK1          SRK2       ...      SRK N

    """
    click.echo("Generating PKI Tree for HABv4")
    hab_tree_generate_command(
        key_type, output, password, encoding, keys_number, duration, serial, srk_is_ca
    )


def generate_key_pair(
    key_type: str,
    encoding: str,
    keys_path: str,
    key_prefix: str,
    idx: int,
    is_ca: bool,
    password: str,
) -> tuple[PrivateKey, PublicKey, str, str]:
    """Generate key pair with the naming convention.

    :param key_type: Key type from get_supported_keys_generators()
    :param encoding: Key encoding - DER, PEM
    :param keys_path: path to keys folder
    :param key_prefix: prefix of the key name e.g. CA
    :param idx: index of the key
    :param is_ca: True if the certificate with this key is certificate authority
    :param password: password of the key
    :return: Tuple of private key, public key, key name and certificate name
    """
    key_param = key_type.lower().strip()
    encoding_param = encoding.upper().strip()
    encoding_enum = SPSDKEncoding.all()[encoding_param]

    # Generate key
    ca_str = "_ca" if is_ca else ""
    key_name = f"{key_prefix}{idx}_{key_param}{ca_str}_key"
    cert_name = f"{key_prefix}{idx}_{key_param}{ca_str}_cert.{encoding_param.lower()}"
    private_key_path = os.path.join(keys_path, f"{key_name}.{encoding_param.lower()}")
    public_key_path = os.path.join(keys_path, f"{key_name}.pub")

    # Get generator according to the provided parameter
    generators = get_supported_keys_generators()
    func, params = generators[key_param]

    # generate public and private key
    private_key = func(**params)
    public_key = private_key.get_public_key()

    # save keys
    private_key.save(private_key_path, password if password else None, encoding=encoding_enum)
    public_key.save(public_key_path, encoding=encoding_enum)
    click.echo(
        f"The {key_prefix}{idx} key pair has been created: {(public_key_path)}, {private_key_path}"
    )

    return private_key, public_key, key_name, cert_name


def ahab_tree_generate_command(
    key_type: str,
    output: str,
    password: str,
    encoding: str,
    keys_number: int,
    duration: int,
    serial: Optional[list[int]],
    srk_is_ca: bool,
) -> None:
    """Generate HAB tree.

    :param key_type: key type
    :param output: output directory
    :param password: password for key protection
    :param encoding: encoding DER or PEM
    :param keys_number: number of keys to generate
    :param duration: duration of certificates in years
    :param serial: list of serial number of SRK certificates
    :param srk_is_ca: True if SRK is CA
    :raises SPSDKAppError: Serial number provided is lower than count of keys
    """
    if not serial:
        default_serials = [0x12345679, 0x1234567A, 0x1234567B, 0x1234567C]
        serial = default_serials[:keys_number]

    if len(serial) != keys_number:
        raise SPSDKAppError("Count of serial numbers does not match the count of certificates")

    encoding_param = encoding.upper().strip()
    encoding_enum = SPSDKEncoding.all()[encoding_param]

    keys_path = os.path.join(output, "keys")
    crts_path = os.path.join(output, "crts")
    os.makedirs(keys_path, exist_ok=True)
    os.makedirs(crts_path, exist_ok=True)

    # Generate key pair for CA keys
    key_prefix = "CA"
    ca_private_key, ca_public_key, ca_key_name, ca_cert_name = generate_key_pair(
        key_type=key_type,
        encoding=encoding,
        keys_path=keys_path,
        key_prefix=key_prefix,
        idx=0,
        is_ca=True,
        password=password,
    )
    ca_cert_path = os.path.join(crts_path, ca_cert_name)

    subject = ca_issuer = generate_name([{"COMMON_NAME": ca_key_name}])
    # generate CA certificate (self-signed certificate)
    ca_cert = Certificate.generate_certificate(
        subject=subject,
        issuer=ca_issuer,
        subject_public_key=ca_public_key,
        issuer_private_key=ca_private_key,
        serial_number=None,
        duration=duration * 365,
        extensions=generate_extensions(
            {"BASIC_CONSTRAINTS": {"ca": True}},
        ),
    )
    ca_cert.save(ca_cert_path, encoding_enum)
    click.echo(f"The CA0 certificate has been created: {ca_cert_path}")
    logger.info(ca_cert)

    # Generate SRK keys
    for idx in range(keys_number):
        srk_private_key, srk_public_key, srk_key_name, srk_cert_name = generate_key_pair(
            key_type,
            encoding,
            keys_path,
            "SRK",
            idx,
            srk_is_ca,
            password,
        )

        srk_cert_path = os.path.join(crts_path, srk_cert_name)
        subject = generate_name([{"COMMON_NAME": srk_key_name}])
        # generate SRK certificate signed by CA certificate
        srk_cert = Certificate.generate_certificate(
            subject=subject,
            issuer=ca_issuer,
            subject_public_key=srk_public_key,
            issuer_private_key=ca_private_key,
            serial_number=serial[idx],
            duration=duration * 365,
            extensions=generate_extensions(
                {"BASIC_CONSTRAINTS": {"ca": srk_is_ca}},
            ),
        )
        srk_cert.save(srk_cert_path, encoding_enum)
        click.echo(f"The SRK{idx} certificate has been created: {srk_cert_path}")
        logger.info(srk_cert)
        # In case the SRK is CA, create SGK certificates
        if srk_is_ca:
            _, sgk_public_key, sgk_key_name, sgk_cert_name = generate_key_pair(
                key_type, encoding, keys_path, "SGK", idx, False, password
            )
            sgk_cert_path = os.path.join(crts_path, sgk_cert_name)
            subject = generate_name([{"COMMON_NAME": sgk_key_name}])
            # generate SGK certificate signed by SRK certificate
            sgk_cert = Certificate.generate_certificate(
                subject=subject,
                issuer=ca_issuer,
                subject_public_key=sgk_public_key,
                issuer_private_key=srk_private_key,
                serial_number=serial[idx],
                duration=duration * 365,
                extensions=generate_extensions(
                    {"BASIC_CONSTRAINTS": {"ca": False}},
                ),
            )
            sgk_cert.save(sgk_cert_path, encoding_enum)
            click.echo(f"The SGK{idx} certificate has been created: {sgk_cert_path}")
            logger.info(sgk_cert)


def hab_tree_generate_command(
    key_type: str,
    output: str,
    password: str,
    encoding: str,
    keys_number: int,
    duration: int,
    serial: Optional[list[int]],
    srk_is_ca: bool,
) -> None:
    """Generate HAB tree.

    :param key_type: key type
    :param output: output directory
    :param password: password for key protection
    :param encoding: encoding DER or PEM
    :param keys_number: number of keys to generate
    :param duration: duration of certificates in years
    :param serial: list of serial number of SRK certificates
    :param srk_is_ca: True if SRK is CA
    :raises SPSDKAppError: Serial number provided is lower than count of keys
    """
    if not serial:
        default_serials = [0x12345679, 0x1234567A, 0x1234567B, 0x1234567C]
        serial = default_serials[:keys_number]

    if len(serial) != keys_number:
        raise SPSDKAppError(
            f"Count of serial numbers does not match the count of certificates {len(serial)} != {keys_number}"
        )

    encoding_param = encoding.upper().strip()
    encoding_enum = SPSDKEncoding.all()[encoding_param]

    keys_path = os.path.join(output, "keys")
    crts_path = os.path.join(output, "crts")
    os.makedirs(keys_path, exist_ok=True)
    os.makedirs(crts_path, exist_ok=True)

    # Generate key pair for CA keys
    key_prefix = "CA"
    ca_private_key, ca_public_key, ca_key_name, ca_cert_name = generate_key_pair(
        key_type=key_type,
        encoding=encoding,
        keys_path=keys_path,
        key_prefix=key_prefix,
        idx=0,
        is_ca=True,
        password=password,
    )
    ca_cert_path = os.path.join(crts_path, ca_cert_name)

    subject = ca_issuer = generate_name([{"COMMON_NAME": ca_key_name}])
    # generate CA certificate (self-signed certificate)
    ca_cert = Certificate.generate_certificate(
        subject=subject,
        issuer=ca_issuer,
        subject_public_key=ca_public_key,
        issuer_private_key=ca_private_key,
        serial_number=None,
        duration=duration * 365,
        extensions=generate_extensions(
            {"BASIC_CONSTRAINTS": {"ca": True}},
        ),
    )
    ca_cert.save(ca_cert_path, encoding_enum)
    click.echo(f"The CA0 certificate has been created: {ca_cert_path}")
    logger.info(ca_cert)

    # Generate SRK keys
    for idx in range(keys_number):
        srk_private_key, srk_public_key, srk_key_name, srk_cert_name = generate_key_pair(
            key_type,
            encoding,
            keys_path,
            "SRK",
            idx,
            srk_is_ca,
            password,
        )

        srk_cert_path = os.path.join(crts_path, srk_cert_name)
        subject = generate_name([{"COMMON_NAME": srk_key_name}])
        # generate SRK certificate signed by CA certificate
        srk_cert = Certificate.generate_certificate(
            subject=subject,
            issuer=ca_issuer,
            subject_public_key=srk_public_key,
            issuer_private_key=ca_private_key,
            serial_number=serial[idx],
            duration=duration * 365,
            extensions=generate_extensions(
                {"BASIC_CONSTRAINTS": {"ca": srk_is_ca}},
            ),
        )
        srk_cert.save(srk_cert_path, encoding_enum)
        click.echo(f"The SRK{idx} certificate has been created: {srk_cert_path}")
        logger.info(srk_cert)
        # In case the SRK is CA, create IMG and CSF certificates
        if srk_is_ca:
            _, csf_public_key, csf_key_name, csf_cert_name = generate_key_pair(
                key_type, encoding, keys_path, "CSF", idx, False, password
            )

            csf_cert_path = os.path.join(crts_path, csf_cert_name)
            subject = generate_name([{"COMMON_NAME": csf_key_name}])
            # generate CSF certificate signed by SRK certificate
            csf_cert = Certificate.generate_certificate(
                subject=subject,
                issuer=ca_issuer,
                subject_public_key=csf_public_key,
                issuer_private_key=srk_private_key,
                serial_number=serial[idx],
                duration=duration * 365,
                extensions=generate_extensions(
                    {"BASIC_CONSTRAINTS": {"ca": False}},
                ),
            )
            csf_cert.save(csf_cert_path, encoding_enum)
            click.echo(f"The CSF{idx} certificate has been created: {csf_cert_path}")
            logger.info(csf_cert)

            # Create IMG certificates
            _, img_public_key, img_key_name, img_cert_name = generate_key_pair(
                key_type, encoding, keys_path, "IMG", idx, False, password
            )

            img_cert_path = os.path.join(crts_path, img_cert_name)
            subject = generate_name([{"COMMON_NAME": img_key_name}])
            # generate CSF certificate signed by SRK certificate
            img_cert = Certificate.generate_certificate(
                subject=subject,
                issuer=ca_issuer,
                subject_public_key=img_public_key,
                issuer_private_key=srk_private_key,
                serial_number=serial[idx],
                duration=duration * 365,
                extensions=generate_extensions(
                    {"BASIC_CONSTRAINTS": {"ca": False}},
                ),
            )
            img_cert.save(img_cert_path, encoding_enum)
            click.echo(f"The IMG{idx} certificate has been created: {img_cert_path}")
            logger.info(img_cert)


@catch_spsdk_error
def safe_main() -> None:
    """Call the main function."""
    sys.exit(main())  # pylint: disable=no-value-for-parameter


if __name__ == "__main__":
    safe_main()
